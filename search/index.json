[{"content":"If you\u0026rsquo;re relatively new to the statically-typed functional programming scene, there\u0026rsquo;s a good chance you\u0026rsquo;ve encountered these fancy-sounding things called \u0026ldquo;algebraic data types\u0026rdquo; (often abbreviated as ADTs), and have been left feeling both a little intimidated by them and confused about what they have to do with algebra. That was my initial experience with them, anyway. I\u0026rsquo;d like to try offering a beginner-friendly introduction to them in a fashion that I think would have helped me understand them sooner.\nAlgebraic data types without Maybe, Either, These, or type classes I\u0026rsquo;m willing to bet you were first exposed to the concept of ADTs through a data type known as Maybe (a.k.a. Option). Then you encountered Either (a.k.a. Result), and then perhaps you saw These mentioned somewhere. These are indeed algebraic data types, but it\u0026rsquo;s not immediately obvious what is algebraic about them, and, to add to the confusion, they are often presented as examples of some other mathematical-sounding concepts that one might mistakenly interpret as the source of their algebraic-ness. I for one thought they were algebraic because of something to do with them having type classes like functor and monad with special \u0026ldquo;laws\u0026rdquo; and what-have-you, and I didn\u0026rsquo;t realize until much later that those concepts were not directly related to algebraic data types.\nThe reality is that types like Maybe and Either aren\u0026rsquo;t any more algebraic than most of the other types you see every day in TypeScript (or whatever language you\u0026rsquo;re using). For example, this union of strings is an algebraic data type:\ntype Size = \u0026quot;small\u0026quot; | \u0026quot;medium\u0026quot; | \u0026quot;large\u0026quot;  And so is this interface for a customer:\ninterface Customer { isPremiumMember: boolean shirtSize: Size }  Actually, if my understanding is correct, almost every type in TypeScript (or a similar language) technically qualifies as an algebraic data type. If that\u0026rsquo;s the case, what is this \u0026ldquo;algebra\u0026rdquo; we keep referring to? What is algebraic about algebraic data types?\nCardinality: the numerical value of a type The first thing you need to know is that there is a numerical relationship between types and the runtime values they represent. This numerical relationship is simple: there is a quantifiable number of runtime values that inhabit every type, anywhere from zero to positive infinity.\nFor example, consider these primitive TypeScript types:\n never has zero possible runtime values null has one possible runtime value, namely, null boolean has two possible runtime values: true and false number and string have somewhere around infinite possible runtime values  The case is the same for user-defined types:\n type Size = \u0026quot;small\u0026quot; | \u0026quot;medium\u0026quot; | \u0026quot;large\u0026quot; has three runtime values, namely, the string literals you see in the type declaration. Customer (defined above) has six possible runtime values, which you can see if you list out every possible combination of values for its two fields.   The number of values that inhabit a type is referred to as the type\u0026rsquo;s cardinality, which is a term borrowed from set theory. It refers to the number of members in a set. Once we recognize that types have such numerical value by way of cardinality, their algebraic-ness begins to come into focus. Algebraic data types are algebraic because you can reason about their cardinality with basic algebra. That\u0026rsquo;s all.\nSums and Products There are two main algebraic data types that you will use day-in and day-out; in fact, you\u0026rsquo;re already using them: sum types and product types. Their names give you a hint as to how their cardinalities are calculated.\nSum types and product types both combine other types to form a new type, but they do so in very different ways, which significantly affects how we calculate their cardinalities.\nSum Types Sum types are so-called because they combine other types in such a way that their cardinality is the sum of the cardinalities of the other types (minus any duplicate members that might exist). The TypeScript documentation call this a union type, which is a type that \u0026ldquo;describes a value that can be one of several types.\u0026quot; We call the \u0026ldquo;several types\u0026rdquo; that make up a sum type its variants. The canonical sum type is boolean whose members may be either the type of literal true or the type of literal false.\nOur Size type from earlier is also an example of a sum or union type:\ntype Size = \u0026quot;small\u0026quot; | \u0026quot;medium\u0026quot; | \u0026quot;large\u0026quot;  We might read this type declaration as follows: A value of type Size is a member of either the type of literal \u0026quot;small\u0026quot;, the type of the literal \u0026quot;medium\u0026quot;, or the type of the literal \u0026quot;large\u0026quot;. The logic of either-or translates to each variant\u0026rsquo;s members being joined with the others' to form a larger set, whose total number of members is the cardinality of the sum type. Since each of these variants is a string literal type, they each have a cardinality of 1. To find the cardinality of Size we perform simple addition:\ntype Size = \u0026quot;small\u0026quot; | \u0026quot;medium\u0026quot; | \u0026quot;large\u0026quot; // 3 = 1 + 1 + 1  This is the algebra of sum types. It holds up no matter what types you throw into a sum type. Here\u0026rsquo;s a slightly more complex example, and it still just amounts to basic addition:\ntype Size = RegularSize | TallSize | XtraSize // 9 = 3 + 3 + 3 type RegularSize = \u0026quot;small\u0026quot; | \u0026quot;medium\u0026quot; | \u0026quot;large\u0026quot; type TallSize = \u0026quot;small-tall\u0026quot; | \u0026quot;medium-tall\u0026quot; | \u0026quot;large-tall\u0026quot; type XtraSize = \u0026quot;xsmall\u0026quot; | \u0026quot;xlarge\u0026quot; | \u0026quot;xxlarge\u0026quot;  Now here\u0026rsquo;s a curveball: What would happen if we threw string into the Size union type? Is it still an algebraic data type? What would be its cardinality?\ntype Size = RegularSize | TallSize | XtraSize | string // ? = 3 + 3 + 3 + ???  Well, what is the cardinality of string? If we use our imaginations a little, we can actually view string as a sum type whose variants are every possible combination of string characters, like this:\ntype string = \u0026quot;\u0026quot; | \u0026quot; \u0026quot; | // ...spaces to infinity | \u0026quot;a\u0026quot; | \u0026quot;aa\u0026quot; | // ...\u0026quot;a\u0026quot;s to infinity | // ...and so on  It would seem then that string is a sum type with an infinite cardinality. So the algebra of sum types still applies to Size, even if it\u0026rsquo;s a bit odd:\ntype Size = RegularSize | TallSize | XtraSize | string // Infinity = 3 + 3 + 3 + Infinity  Of course, this is a pretty bogus type that you\u0026rsquo;d never write. But it shows that the algebra of sum types holds even if we\u0026rsquo;re dealing with types of infinite cardinality.\nWith this understanding of sum types, we can now see what is algebraic about data types like Maybe\u0026lt;T\u0026gt; and Either\u0026lt;L, R\u0026gt;. They are just examples of sum types. However, because they have generic type parameters, we don\u0026rsquo;t have enough information to determine their cardinality right away.\ninterface Nothing { tag: \u0026quot;Nothing\u0026quot; } interface Just\u0026lt;T\u0026gt; { tag: \u0026quot;Just\u0026quot;, value: T } type Maybe\u0026lt;T\u0026gt; = Nothing | Just\u0026lt;T\u0026gt; // ? = 1 + ?  Because we don\u0026rsquo;t know what T is, we can\u0026rsquo;t know its cardinality, and therefore we can\u0026rsquo;t know the cardinality of Maybe. But since we know the algebra of sum types, we can still reason about Maybe algebraically. Just replace the question marks with variables and suddenly we see that it really is algebra!\ntype Maybe\u0026lt;T\u0026gt; = Nothing | Just\u0026lt;T\u0026gt; // y = 1 + x  Once Maybe is supplied with a type argument, we can then plug in the numbers to solve for the cardinality. For example, Maybe\u0026lt;Size\u0026gt; would work out like so:\nMaybe\u0026lt;Size\u0026gt; = Nothing | Just\u0026lt;Size\u0026gt; // 4 = 1 + 3  Either is similarly straightforward:\ninterface Left\u0026lt;L\u0026gt; { tag: \u0026quot;Left\u0026quot;, left: L } interface Right\u0026lt;R\u0026gt; { tag: \u0026quot;Right\u0026quot;, right: R } type Either\u0026lt;L, R\u0026gt; = Left\u0026lt;L\u0026gt; | Right\u0026lt;R\u0026gt; // z = x + y  If we had Either\u0026lt;boolean, Size\u0026gt;, then finding its cardinality is as simple as 2 + 3 = 5.\nThat about sums it up for sum types.\nProduct Types Product types are so-called because they combine other types in such a way that their cardinality is the result of multiplying the cardinalities of the other types they combine. The way they do this is by combining multiple types into a structure. In TypeScript, the structures we can use for product types are tuples and object types with static keys (which can be expressed as interfaces, classes, and object literal type aliases). Our Customer interface from earlier is an example of a product type:\ninterface Customer { isPremiumMember: boolean shirtSize: Size }  It combines Size (cardinality 3) and boolean (cardinality 2) into a structure by specifying these types on keys of an object. We can count the number of values that inhabit the type of Customer by listing out all the possibilities:\n { isPremiumMember: true, shirtSize: \u0026quot;small\u0026quot; } { isPremiumMember: true, shirtSize: \u0026quot;medium\u0026quot; } { isPremiumMember: true, shirtSize: \u0026quot;large\u0026quot; } { isPremiumMember: false, shirtSize: \u0026quot;small\u0026quot; } { isPremiumMember: false, shirtSize: \u0026quot;medium\u0026quot; } { isPremiumMember: false, shirtSize: \u0026quot;large\u0026quot; }  However, on a more complicated product type, it would be unwieldy, if not impossible, to try to find the cardinality by listing out of possible values. Instead we can use the algebra of product types to calculate it\u0026rsquo;s cardinality:\n// Size x boolean = Customer // 3 x 2 = 6  If Customer had another field, or ten more, it\u0026rsquo;s still just as easy to calculate its cardinality:\ninterface Customer { favoriteFood: Food isPremiumMember: boolean shirtSize: Size } type Food = \u0026quot;hotdog\u0026quot; | \u0026quot;burger\u0026quot; | \u0026quot;pizza\u0026quot; | \u0026quot;salad\u0026quot; | \u0026quot;pretzel\u0026quot; | \u0026quot;nachos\u0026quot;  Now Customer combines three types into a structure, and look how much its cardinality has grown:\n// Food x Size x boolean = Customer // 6 x 3 x 2 = 36  The algebra of product types work the same regardless of the structure we choose. If for some reason we decided to represent Customer as a tuple, the math would work out the same:\ntype Customer = [Food, Size, boolean] // 36 = 6 x 3 x 2  This makes sense because we\u0026rsquo;ve simply replaced the keys of an object/record/struct with the indexes of a tuple.\nWhen the product type we\u0026rsquo;re dealing with is generic (i.e. it has type parameters, like Maybe\u0026lt;T\u0026gt; and Either\u0026lt;L, R\u0026gt;), we are left with a simple equation to be solved when the type is fully resolved. As an example, we can look at the canonical product type known as Pair\u0026lt;A, B\u0026gt;, a simple structure over two types. Again, it could be implemented as either a tuple or object type. For this example we\u0026rsquo;ll use a tuple:\ntype Pair\u0026lt;A, B\u0026gt; = [A, B]  Since we do not know what A and B are yet, all we know is the equation to solve for the cardinality of Pair\u0026lt;A, B\u0026gt;:\ntype Pair\u0026lt;A, B\u0026gt; = [A, B] // z = x * y  So if we had a function that returned Pair\u0026lt;boolean, Size\u0026gt;, we just plug in A = 2 and B = 3 and find that our function can only return 2 * 3 or 6 possible values.\nTake a look at these other Pairs and use the algebra of product types to determine their cardinality:\n Pair\u0026lt;null, null\u0026gt; Pair\u0026lt;never, Food\u0026gt; Pair\u0026lt;boolean, Maybe\u0026lt;boolean\u0026gt;\u0026gt; Pair\u0026lt;Either\u0026lt;Error, Customer\u0026gt;, Maybe\u0026lt;Size\u0026gt;\u0026gt; (use the original Customer)  By understanding the algebra of sums and products, one can easily calculate the number of possibilities these types encode. That\u0026rsquo;s the power of algebraic data types!\nWhy the Algebra of Types Matters After getting through all that, it\u0026rsquo;s reasonable to wonder why any of this matters. So types have cardinality and I can calculate the cardinality of a type with some basic math. So what?\nIn my own experience, the main advantage I\u0026rsquo;ve experienced from understanding the algebra of types is that it makes me much more aware of how software complexity is directly tied to the aggregate complexity of the data models we choose to use throughout our programs, and it enables me to design better data models that reduce the cognitive complexity of writing correct, error-free programs.\nThink about what a type\u0026rsquo;s cardinality translates to in a program: cases or branches that need to be handled, and we all know how tough heavily branching code is to deal with. Imagine implementing a function whose argument has a cardinality of 4 versus a function that whose argument has a cardinality of 36 (or Infinity!). That function needs to handle every possible case in order to avoid a runtime error or some other higher level business logic error. That\u0026rsquo;s much easier to do when your cardinality is low. Often times, a high cardinality is indicative of a poorly designed data model, and understanding the algebra of types can help you design a simpler or more accurate one that makes your program less complicated to reason about.\nWhat We Learned Algebraic data types sound complicated, but they\u0026rsquo;re really quite simple and surprisingly ubiquitous. We can view types in terms of the set of values that the compiler says are valid members of that type, which means we can think about types in terms of a set\u0026rsquo;s cardinality, that is, the number of members in the set. When we see types in terms of cardinality, it\u0026rsquo;s easier to see what math might have to do with types.\nSum types and product type are the two algebraic data types we commonly make use of in TypeScript (and many other typed languages).\n A sum type is a type whose members may be members of one its variant types, and its cardinality is the sum or the cardinalities of the variants. boolean is the canonical example of a sum type. The well-known Maybe and Either data types are examples of sum types as well. A product type is a type that combines other types into a structure, like a tuple or object/struct. The cardinality of a product type is the product of the cardinalities of the types it combines. The canonical example of a product type is Pair\u0026lt;A, B\u0026gt;, which is simple structure that holds two values, one of any type A and the other of some other type B.  Understanding the algebra of types helps us to avoid accidental complexity in our programs by designing better data types to model the problems we\u0026rsquo;re solving.\n","date":"2019-05-30","permalink":"https://derrickbeining.github.io/post/2019/05/30/whats-algebraic-about-algebraic-data-types/","tags":[],"title":"What's Algebraic About Algebraic Data Types?"},{"content":"I want to demonstrate two foundational techniques you need to know to practice functional programming: function composition and curried functions. We\u0026rsquo;ll learn what these terms mean, how to implement them, and the advantages of using them.\nThese techniques are applicable in any programming language where functions are first-class values, meaning they can be passed around like any primitive value. For the purposes of this post, we will be implementing these patterns in JavaScript.\nFunction Composition Function composition sounds fancy, but it\u0026rsquo;s really not. It\u0026rsquo;s actually just a way to automate something we all do manually anyway.\nImagine we have these three functions:\nconst getDescription = (obj) =\u0026gt; obj.description const truncate = (str) =\u0026gt; str.slice(0, 100) const appendEllipsis = (str) =\u0026gt; `${str}...`  And we want to get the description from an item and format it to be 100 characters max and with a trailing ellipsis.\nWithout function composition, we might do something this:\nconst description = getDescription(item) const truncatedDescription = truncate(description) const descriptionWithEllipsis = appendEllipsis(truncatedDescription)  We set the return value of some function to a variable, and then turn around and pass that variable into the next function, and so on. This is a really common practice for most programmers. The only purpose of those variables is to pass them to the next function, so really we could just do this:\nappendEllipsis(truncate(getDescription(item))))  But that\u0026rsquo;s a little awkward to read and evaluate in your head, so folks generally don\u0026rsquo;t do that. But are one-off intermediate variables really the solution? Must we choose between being writing verbose readable code or concise unreadable code? We\u0026rsquo;re programmers; can\u0026rsquo;t we automate the process of passing output to input?\nWe can do that by writing a function called composeLTR (read: compose left-to-right) 1, which takes any number of functions as arguments, and then returns a new function that will pass its arguments to the first function, then pass the return value to the next function, and so on.\nHere\u0026rsquo;s the sales pitch. Using composeLTR would transform our code into this:\nconst extractFormattedDescription = composeLTR( getDescription, truncate, appendEllipsis ) extractFormattedDescription(item) // =\u0026gt; 'This is a truncated description...'  No more setting return values on temporary values and it\u0026rsquo;s still pretty readable. That\u0026rsquo;s great, because I hate having to come up with unique names for everything and I hate hard-to-read code.\nImplementing It Implementing composeLTR isn\u0026rsquo;t much work, but it can make your head spin a little bit at first. It looks like this:\nconst composeLTR = (...fns) =\u0026gt; fns.reduce((first, second) =\u0026gt; { return (...args) =\u0026gt; second(first(...args)) })  All it does is exactly what we said: it takes many functions and returns a new function that automates the passing of input and output between those functions.\nCurried Functions Currying is a concept named after Haskell Curry, who was a logician and mathematician by vocation. It\u0026rsquo;s an odd term for an easier-done-than-said programming technique. I\u0026rsquo;d rather just show you a curried function than try to explain what it is.\nSay you have function replaceAtIdx, that takes index, value, and array, and returns a copy of the array with the value at index set to value. It might look like this:\nconst replaceAtIdx = (index, value, array) =\u0026gt; { return array.map((val, idx) =\u0026gt; idx === index ? value : val) } replaceAtIdx(2, 'hi!', ['zero', 'one', 'two']) // =\u0026gt; ['zero', 'one', 'hi!']  The curried version of replaceAtIdx wouldn\u0026rsquo;t look too terribly different. It would just look like this:\nconst replaceAtIdx = (index) =\u0026gt; (value) =\u0026gt; (array) =\u0026gt; { return array.map((val, idx) =\u0026gt; idx === index ? value : val) } replaceAtIdx (2) ('hi') (['zero', 'one', 'two']) // =\u0026gt; ['zero', 'one', 'hi!']  Instead of taking all three arguments at once, our curried version of replaceAtIndex breaks the original \u0026ldquo;trinary\u0026rdquo;2 function into three \u0026ldquo;unary\u0026rdquo;3 functions, each returning another function which serves to act as a closure over the previous argument(s) and to take the next argument for the computation. When the last function is applied to its argument, then the block of code runs. That\u0026rsquo;s really all there is to currying. You just break a function of arity N down into N functions of arity 1.\nCurrying is admittedly a very strange concept when first learning functional programming from a procedural and/or object-oriented background. But it begins to make a lot more sense when you regularly make use of functional composition patterns, which is what we\u0026rsquo;re trying to do!\nI\u0026rsquo;ll try to illustrate with example. Let\u0026rsquo;s adapt the code from the section on function composition:\nImagine we have these three curried functions:\nconst get = (propName) =\u0026gt; (obj) =\u0026gt; obj[propName] const truncate = (length) =\u0026gt; (str) =\u0026gt; str.slice(0, length) const append = (appendage) =\u0026gt; (str) =\u0026gt; `${str}${appendage}`  Since they are curried, we can use composeLTR like this:\nconst extractFormattedDescription = composeLTR( get('description'), truncate(100), append('...') ) extractFormattedDescription(item) // =\u0026gt; 'This is a truncated description...'  Each function requires two arguments in order to evaluate a result, but in the composeLTR pipeline, we only provide the first argument to each function so that we are composing the functions they return. The term for this idea of supplying some-but-not-all of the arguments a curried function requires is called \u0026ldquo;partial function application,\u0026rdquo; or more succinctly, \u0026ldquo;partial application.\u0026rdquo; Partial application is often conflated with currying because it is so closely related, but the distinction is that partial application is made possible by currying.\nOnce you start using composition, it becomes very natural to use curried functions and partially apply them. Currying allows you to build specialized functions from more generic functions (like creating getDescription with get('description')). Both of these together form a very powerful little technique that can transform your code base from verbose and full of intermediate variables, to very concise and expressive.\nCurrying and composition are arguably two of the most fundamental and versatile programming design patterns for code reuse. You use currying to build specialized functions from more general ones. Simply changing an argument creates a whole new specialized function, yet you didn\u0026rsquo;t have to write any new code; you just invoked a function! You use composition to string together however many functions you need to perform your desired transformation on the value, (leveraging your curried general functions along the way), to build up a super-specialized function that would have taken you twice the code to implement imperatively.\nOnce you experience the level productivity and flow that comes from solving problems this way, you\u0026rsquo;ll wonder how you ever got anything done before. And once you\u0026rsquo;re hooked on this power, you\u0026rsquo;ll start to get frustrated by the fact that native JS methods and most JS libraries don\u0026rsquo;t use currying. You\u0026rsquo;ll start to wish there were libraries that made it easier to use these basic techniques on every project because of how productive they make you and how tidy they make your code.\nHmm\u0026hellip; that sounds like a really good segue for talking about ramda.js. All of their functions are curried and designed specifically for functional composition!\n  composeLTR is commonly known as pipe \u0026#x21a9;\u0026#xfe0e;\n trinary - arity three; i.e., takes three arguments \u0026#x21a9;\u0026#xfe0e;\n unary - arity one; i.e., takes one argument \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2018-07-04","permalink":"https://derrickbeining.github.io/post/2018/07/04/currying-and-function-composition/","tags":[],"title":"Currying and Function Composition"},{"content":"Now that I\u0026rsquo;ve been accepted to Fullstack Academy\u0026rsquo;s software engineering immersive program, I figured I\u0026rsquo;d share how I prepared to pass the admissions test.\nPlease note that not all dev bootcamps have a coding challenge in their admissions process. Some programs are designed for people starting at square one with zero prior knowledge. However, I would like to suggest to you that you\u0026rsquo;re wasting your time and money going to a bootcamp that starts you at square one. There are tons of free online resources that you can use to learn everything they\u0026rsquo;d teach in the first month. It makes no sense to pay tons of money to be taught the most basic aspects of programming and a programming language when all of that information is low hanging fruit freely or cheaply avaliable to you all over the internet. You should only pay the big bucks in order to get instruction and guidance on the more intermediate and advanced topics that you\u0026rsquo;d otherwise struggle to piece together on your own. There\u0026rsquo;s only so much you can accomplish a three-month span. Why waste that time learning things you could learn on your own? Teach yourself the basics and go to a school that will take you from 60 to 100+mph rather than going somewhere that will only be able to take you from 0-60.\nIf you\u0026rsquo;re convinced by this advice, then what I\u0026rsquo;m offering here is basically one way to prepare to get into a non-beginner bootcamp.\nWhat I did was pretty straight forward: I studied and practiced JavaScript full-time for about a month. No HTML. No CSS. No jQuery. Just JavaScript. All day, every day, for a month. You could do another language. The point is to pick a programming language like Java, JavaScript, Ruby, C#, or whatever you think you\u0026rsquo;re interested in, and get comfortable with it. I chose JavaScript because I was persuaded by the rationale provided by David Yang, a co-founder of Fullstack Academy, for why they decided to base their curriculum on fullstack JavaScript rather than teaching Ruby for back-end and JavaScript for front-end.\nSo here\u0026rsquo;s what I did step by step, plus a little commentary:\nWeek 1: Codecademy First I completed all of the lessons and exercises in Codecademy\u0026rsquo;s Introduction to JavaScript course. Actually, the course I did was an older version of this course, so I can\u0026rsquo;t really offer an opinion about the current state of the course.\nAnyhow, this course was my first real introduction to programming in general and JavaScript in particular. It was my first exposure to variables, if/else statements, functions, arrays, for-loops, and so on.\nThe good part about this course and Codecademy in general is that it is designed to be approachable and accessible to absolute beginners with no prior knowledge. All of the exercises were pretty straight-forward and not too difficult. They don\u0026rsquo;t want you to be overwhelmed by complexity or to get stuck and feel discouraged about your capability to learn programming.\nThe bad part about this course (and from what I\u0026rsquo;ve seen from other Codecademy courses) is that there is sometime too much hand-holding and not enough detail explaining concepts for you to really feel like you know what\u0026rsquo;s going on or understand why the thing you wrote worked. I remember several instances where I managed to write code that passed the specifications allowing me to progress to the next problem, but I had no idea why what I wrote was correct. Usually it was because the answer was basically embedded in the instructions or in the examples, so I could figure out what I was supposed to write pretty easily, but I didn\u0026rsquo;t know why that was right.\nThe value of this course is the non-threatening exposure you get to basic sytax, programming vocabulary, and concepts. However, it was so non-threatening that I found it\u0026rsquo;s educational value to be pretty minimal. Nevertheless, this is where I started and certainly didn\u0026rsquo;t hurt me to startd at such a basic level. If you don\u0026rsquo;t know the difference between [] and {} in JavaScript, then this may very well be the course for you.\nWeek 2: Fullstack Academy\u0026rsquo;s JavaScript Jumpstart Honestly, if you\u0026rsquo;re looking to learn JavaScript, I\u0026rsquo;d say start here.\nAfter completing Codecademy\u0026rsquo;s course on JavaScript, I managed to get a discount code for Fullstack Academy\u0026rsquo;s JavaScript Jumpstart course (link further below), which is basically their equivalent to the Codecademy course. It\u0026rsquo;s meant for absolute beginner\u0026rsquo;s and therefore covers many of the same concepts and syntax. However I found this course to be of much greater educational value than the Codecademy course.\nThis course provided much of the detail that I felt was lacking in the previous course. The whole time, I felt like I was really learning fundamental programming concepts and understanding how JavaScript behaved. Also, the exercise problems were on point. They were challenging enough that you couldn\u0026rsquo;t haphazardly solve them without understanding why your code worked, but they were also accessible enough that almost anyone could certainly solve them as long as you paid attention during the lesson video. I remember feeling very satisfied after solving each problem because it was genuinely challenging and I knew that by solving it, I had demonstrated that I had really understood the previous lesson.\nMy critiques of this course are pretty negligible. I remember there being a couple places where quality control definitely had room for improvement, e.g. the occasional ambiguity in the lesson or problem wording that made it more difficult to solve the problem. Other than that, the only other thing I would tell you is that while the instructor in the lesson videos may not be all that smooth in front of a camera (I doubt I\u0026rsquo;d be much better), the content of his lessons are gold. Very well done.\nThe Jumpstart course has now been incorporated into Fullstack Academy\u0026rsquo;s new (and FREE!) Bootcamp Prep course, which was not available when I was preparing for the admissions test, so I can\u0026rsquo;t say anything about the rest of the prep course. But I\u0026rsquo;m willing to bet it\u0026rsquo;s excellent. I can\u0026rsquo;t recommend JavaScript Jumpstart highly enough.\nWeeks 3-4: Hack Reactor Prep After completing Fullstack Academy\u0026rsquo;s JavaScript Jumpstart course, I felt much more confident in my programming abilities and my interest in becoming a programmer. So I decided I needed to keep the momentum going and really make sure I was ready for a bootcamp experience. So I decided to do a bootcamp prep course. At the time, Fullstack Academy did not have the free, self-paced prep course that they now have available. So I decided to do Hack Reactor\u0026rsquo;s prep course because I was also considering applying there. I\u0026rsquo;m fairly certain that Fullstack Academy\u0026rsquo;s prep course is completely equivalent, so everything I say here can very likely apply to Fullstack\u0026rsquo;s prep course as well.\nThis prep course was a beast, to say the least. It\u0026rsquo;s advertised as containing about 90 hours of material with over 150 JavaScript exercises, and they assert that 85% of peopel who finish the premium version of the prep program and complete a technical interview will be admitted to Hack Reactor. The only difference between the free version and the premium version is that premium students get a lot more personal interaction and support from staff. I figured, if I can knock out the free version on my own in two weeks or so, then my chances of getting into Hack Reactor or a similar school will probably just as good if not better than their touted 85%. So that\u0026rsquo;s what I did.\nIt was hard as crap, thoughâ€“in a good way, of course. There were definitely points where I was honestly considering paying to get the premium support from instructors. Doing this course was probably the most exhilerating part of my journey to getting into Fullstack. It exposed me to more advance concepts in programming and the JavaScript language and provided an immense amount of opportunity to exercise and apply my understanding of new concepts. Every problem was a genuine challenge such that every time I solved one, I felt even more confident in my ability to keep improving as a programmer.\nThe course is divided into four modules, each getting progressively more difficult. The majority of the exercises are in the second module. This marathon of exercises is designed to help you know JavaScript basics cold, so that when you begin learning more advanced concepts, you won\u0026rsquo;t even have think about how to implement basic parts of your code. The idea is that you don\u0026rsquo;t want to have to stop and think about how you go about accessing each element in an array when you\u0026rsquo;re trying to write a function that is meant to reduce the contents of the array to a single calculated value. You want to get to the point where you\u0026rsquo;re so familiar with the basics that you\u0026rsquo;re able to abstract them away in your mind and think about your code at a higher level or purpose.\nThe third module introduces you to concepts of test-driven development, writing good code, and provides more challenging exercises that reflect the kinds of questions you might face during the admissions interviews.\nThe fourth module is just a handful of more challenging problems to prepare you for doing similar problems during the admissions interview.\nI really highly recommend doing this course (or Fullstack\u0026rsquo;s) prior to applying to whatever bootcamp you\u0026rsquo;re looking to get into. If you can get through it, you can be pretty certain that you have what it takes to succeed in an accelerated learning experience like Hack Reactor or Fullstack Academy.\nOne Month Is All It Takes That\u0026rsquo;s pretty much everything I did to prepare. After finishing Hack Reactor\u0026rsquo;s prep course, I applied to Fullstack and managed to pass both of their coding assessments (they have two, in case you didn\u0026rsquo;t know). I just spent all day, every day reading and doing coding exercises for about a month straight. I think doing it in such a consentrated way helped me advance more quickly in my understanding. I imagine that if I had tried to pace it more slowly, I\u0026rsquo;d end up wasting a lot of time having to review and refresh myself on things I had already covered. Because I never really took a break, I was able to continually and quickly build on what I had just learned the previous day. But I recognize that a lot of people probably can\u0026rsquo;t afford to do that. If that\u0026rsquo;s the case for you, just know up front that you may find the process to take a bit longer than you expect because you\u0026rsquo;ll have to keep reviewing things.\nLike I said, this is just how I managed to prepare to get into a good programming school. There are tons of resources out there, many of which may very well be better than the resources I used. The point is to start somewhere and go at it hard until you feel confident that you understand what you\u0026rsquo;re doing and you\u0026rsquo;re sure that you like doing it.\nIf you\u0026rsquo;ve found other resources helpful as you\u0026rsquo;ve prepared to get into a intensive programming school, share them in the commments to point others in the right direction!\n","date":"2017-05-01","permalink":"https://derrickbeining.github.io/post/2017/05/01/bootcamp-prep-how-i-prepared-to-get-into-a-coding-bootcamp-without-any-prior-experience/","tags":[],"title":"Bootcamp Prep: How I Prepared to Get Into a Coding Bootcamp Without Any Prior Experience"},{"content":"This watershed moment in my life seems worthy of documentation. So I thought, \u0026ldquo;Why not start a blog? The internet can always use more blogs, right?\u0026rdquo;\nRight?\nWell, whatever. Here\u0026rsquo;s my blog.\nBackground I\u0026rsquo;ve been deliberating for some months now about whether or not I should drop out of my master\u0026rsquo;s degree program and learn to compose software professionally.\nI\u0026rsquo;ve been in seminary for the past two years pursuing a Master of Divinity degree, studying theology, biblical studies, and pastoral ministry, because I wanted to be a pastor. That desire sprang from several discoveries and experiences I had over the course of my adolescent and college years, experiences which upended my decade-long streak of skepticisim about the Christian religion and the historicity of the Bible. I had encountered the Reformed theological tradition (also sometimes referred to as Calvinism) and its most brilliant scholars and theologians, past and present. In their writings and sermons, I found all the answers to my biggest hang-ups about Christianity and the Bible. I found them to offer the most sensible approach to interpreting the Bible, an approach that took the original authors seriously as historical individuals and communicators and that believed them to be commissioned and impelled by God to write what they did. It made the whole Bible finally make sense to me and preserved it from the typical hyper-subjective interpretations I had usually gotten from other Christians.\nThese findings and this new perspective on Christianity and the Bible (new to me, at least) were so revolutionary for my thinking and outlook on all aspects of life, it was truly copernican. I wondered why more people were not familiar with Reformed Christianity or at least its contributions to theology and biblical interpretation. I was so enthused about my newfound faith in Christ and understanding of the Bible that I wanted to pursue a degree in biblical studies and spend my life helping others understand and live by the teachings of God\u0026rsquo;s Word. Perhaps this is my calling, I thought.\nSo that\u0026rsquo;s (mostly) how I got here. But now, after two years of very intense seminary curriculum, my urge to be a pastor has waned dramatically. That sense of calling now feels void. I have learned more about the Bible, theology, and the history of Christianity than I ever imagined possible, but I no longer have the desire to play the role of pastor and Bible teacher in peoples' lives. It\u0026rsquo;s not 100% clear to me why I\u0026rsquo;ve had this change of heart. Many reasons do come to mind, but none of them (I don\u0026rsquo;t think) are anything I wasn\u0026rsquo;t already aware of prior to attending seminary. Something about me has changed that makes the work of a pastor seem unattractive to me now.\nI think some of what\u0026rsquo;s going on is that I\u0026rsquo;ve learned just about all I want to know about Christianity and the Bible. I don\u0026rsquo;t have a lot of curiousity left for it. And the Bible and Christian doctrine don\u0026rsquo;t exactly change, so there isn\u0026rsquo;t much more to learn or keep up with anyway. On top of that, pastors already tend to focus their teaching and preaching on a fairly small subset of Christian teachings that is more suitable for addressing the concerns of lay people. I don\u0026rsquo;t really want my life\u0026rsquo;s work to involve reiterating over the same topics week after week, year after year. I\u0026rsquo;d rather be working on projects that require me to continually learn new things, gain new skills, and solve new problems every day.\nThere\u0026rsquo;s so much more I could say. But I should leave it there. I just don\u0026rsquo;t want to be a pastor, and therefore it doesn\u0026rsquo;t make sense for me to spend another two years in seminary for a degree I don\u0026rsquo;t need.\nSo yesterday, I submitted my academic withdrawal papers and stopped going to class.\nNow I\u0026rsquo;m learning to code.\nWhy Software? I have also been working part-time for the past two years. I manage the marketing for a private school here in Philadelphia, creating and managing the website, running email and social media ad campaigns, digitizing the application process, yada-yada-yada. I was not qualified for the job when I started, but thankfully the school didn\u0026rsquo;t have the budget to hire someone who was, so I got an opportunity to learn some new things.\nAs a part-time marketer, I needed to focus my efforts. My intuition was that digital marketing would have the highest return on investment among the various marketing avenues, so that\u0026rsquo;s what I invested my time in. As I got a feel for what tools to use and how to get the best outcomes, I started to realize that a lot of these online tools had useful features and integrations I wanted to use, but they required knowledge of coding to set up. So I learned how HTML and CSS work. I learned bits about JavaScript here and there. I learn how browsers read HTML and execute scripts, how to load scripts asynchronously without breaking dependency chains. I tinkered with Chrome\u0026rsquo;s developer tools and figured out how to manipulate DOM elements. I slowly got my hands into more and more code and found myself feeling an enjoyable sense of satisfaction when I managed to successfully implement some bit of code (usually someone else\u0026rsquo;s) into our school\u0026rsquo;s website or marketing tech-stack. I wanted to know more. And that\u0026rsquo;s where it all started: tinkering on the job as a marketer.\nI\u0026rsquo;ve also had the chance to play with a lot of different software on the job as I\u0026rsquo;ve looked for tools to help me accomplish my marketing goals and as I\u0026rsquo;ve tried to help the administrative staff implement some software for information management, communication, grading, and so on. Playing with all these different web apps and software made me aware of just how good and how bad software can be. This made me super aware of what I liked and didn\u0026rsquo;t like about various apps, and made me begin thinking about features that I thought would offer an improvement to the currently offered product. This experience playing with all kinds of different apps simply added fuel to the flame. I wanted to build a superior product of my own.\nWhat\u0026rsquo;s Ahead: Learn, Learn, Learn, Learn, Learn \u0026hellip;and Hopefully a Job Of course, I haven\u0026rsquo;t actually had any real programming experience at this point, so I don\u0026rsquo;t know 100% if I\u0026rsquo;ll even like doing it professionally. But my intuition is that my personality and intellectual aptitudes suit me very well for it. The only way to really know, though, is to start learning. And there is a lot to learn.\nI actually started doing freeCodeCamp in my (very scarce) free time a couple months ago, working through their front-end certificate course, which primarily covers HTML, CSS, and JavaScript. More recently, I also started Codecademy\u0026rsquo;s JavaScript course last week, which covers the most basic fundamentals of the JavaScript programming language. I\u0026rsquo;ve almost finished it already. I also bought some courses on Udemy that cover both front-end and back-end programming. A couple of the courses are full-length bootcamp experiences. I\u0026rsquo;m pretty excited to try these out because of how comprehensive they are and how well-reviewed they are.\nI\u0026rsquo;m also researching actual coding bootcamps like App Academy, Flatiron School, and Thinkful. These programs are quite expensive, but from what I\u0026rsquo;ve read online, they\u0026rsquo;re very successful at making their students into competent programmers who get good jobs. Having a program like that to provide a structured curriculum and a motivating and accelerated learning environment sounds really appealing to me. It has been really overwhelming so far trying to figure out what to learn on my own!\nThe little that I have learned so far has been pretty enjoyable, especially JavaScript. A lot of it just feels like logic puzzles and basic problem solving, which I find to be pretty stimulating and satisfying when solved. However, I\u0026rsquo;ve foudnd that working on this stuff alone for days on end isn\u0026rsquo;t the best, that\u0026rsquo;s another reason why doing a intensive bootcamp experience looks pretty attractive to me.\nI have no idea where this road is going to take me or how long it\u0026rsquo;s going to take to learn all that I need to know in order to be qualified for a software engineering role. But I feel a steely resolve to grit my teeth and make it happen as fast as possible. It is a little nerve racking attempting to become a software engineer without a computer science degree, but I know for a fact I can learn everything on my own that I could in a university classroom. I have yet to fail to learn anything that I have set my mind to. I have no reason to think programming will be any different. And while there may be some disadvantage in the job hunt when it comes to being evaluated on paper, I know there are plenty of recruiters and HR managers out their in tech departments and companies who know that it is skill and knowledge that matters, not diplomas or extra letters after names. If I can prove my knowledge and abilities by building real programs and apps that are on par with or better than what any CS grad could do, then I am confident I will have no trouble finding work.\nLet\u0026rsquo;s hope I\u0026rsquo;m right!\n","date":"2017-03-18","permalink":"https://derrickbeining.github.io/post/2017/03/18/square-one-that-time-i-quit-grad-school-to-become-a-programmer/","tags":[],"title":"Square One: That Time I Quit Grad School to Become a Programmer"}]